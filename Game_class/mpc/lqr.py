import numpy as np
from numpy.linalg import inv, eig

A = np.array([[0.706, -0.001, -0.716, 0.625, -0.012, 0.651, 0.122, 0.014, 0.605, -0.453, 0, -0.521], 
              [-0.004, 0.709, -0.774, -0.007, 0.627, 2.282, 0.019, 0.111, -2.839, -0.009, -0.447, 1.331], 
              [0, 0, 0.740, 0, 0, 0.496, 0, 0, 0.055, 0, 0, -0.291], 
              [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
              [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
              [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
              [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], 
              [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
              [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], 
              [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], 
              [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], 
              [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]])

B = np.array([[0.697, -0.059, -0.008, 1.066, 0.131, 0.044, 0.675, -0.125, -0.050, 6.416, 0.132, 0.051], 
              [-0.245, 0.271, 0.032, 0.705, 1.477, 0.029, -0.541, 0.929, -0.131, 0.217, 6.034, 0.083], 
              [0, 0.001, 0, 0, -0.001, 0.004, -0.001, 0.002, 0.003, 0.001, 0, 0.006], 
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])

Kd = np.array([[1.16710220e-02,-5.02184812e-03,-4.27420512e-02,1.03231503e-02
,-4.60565174e-03,-1.52042774e-02,1.85577251e-03,-5.44495920e-04
,3.81983869e-02,-7.39115171e-03,3.14761538e-03,-7.38547531e-03]
,[-1.33283759e-03,4.82328544e-03,4.42804750e-01,-1.15777951e-03
,4.24608708e-03,1.35328156e-01,-5.72003463e-05,7.33755731e-04
,-1.21893621e-01,7.55709916e-04,-3.02673738e-03,-1.19547853e-01]
,[-1.65971779e-04,5.70533824e-04,-4.62403891e-04,-1.49182868e-04
,5.05547717e-04,1.67824559e-03,-1.25667996e-05,8.50819812e-05
,-2.41458376e-03,9.69681422e-05,-3.58814938e-04,1.18989023e-03]
,[1.66655316e-02,1.12922520e-02,-1.00622610e-01,1.46528488e-02
,9.70156281e-03,3.23717890e-02,3.16129872e-03,2.08336947e-03
,-1.46797487e-02,-1.08552498e-02,-7.12268822e-03,2.95846653e-02]
,[5.93413263e-04,2.58187546e-02,-5.05118547e-01,3.59216981e-04
,2.27809528e-02,-4.55396399e-02,7.79492355e-04,3.99944516e-03
,5.77876966e-03,-7.81999891e-04,-1.62529259e-02,1.85926389e-01]
,[4.06367177e-04,4.66645973e-04,1.78528088e+00,5.21923507e-04
,2.98283858e-04,4.85922764e-01,2.30485228e-04,1.32709089e-04
,-4.07464839e-01,-3.44022957e-04,-2.67034195e-04,-5.17376522e-01]
,[1.17061932e-02,-1.02011499e-02,-4.78833785e-01,1.03374875e-02
,-9.14581982e-03,-1.51520335e-01,1.68130985e-03,-1.35939463e-03
,1.59273174e-01,-7.31014845e-03,6.39972096e-03,1.10996089e-01]
,[-3.20466677e-03,1.64541805e-02,8.73483540e-01,-2.82364501e-03
,1.45023732e-02,2.90620105e-01,-1.79803842e-05,2.51156478e-03
,-2.70205874e-01,1.74551350e-03,-1.03363623e-02,-2.24462002e-01]
,[-8.85487660e-04,-2.24881420e-03,1.34999032e+00,-6.46530631e-04
,-2.04937095e-03,3.56880025e-01,-1.02558495e-04,-3.26981599e-04
,-2.97830240e-01,5.46502848e-04,1.43617292e-03,-3.94041008e-01]
,[1.04651592e-01,-2.78341180e-03,-2.68094097e-02,9.24055368e-02
,-4.07778952e-03,1.08558740e-01,1.78474253e-02,1.67679938e-03
,8.25228573e-02,-6.69829603e-02,1.64865421e-03,-1.04027450e-01]
,[-4.45894294e-03,1.05894470e-01,-2.06619739e-01,-4.43956771e-03
,9.34306007e-02,3.10376762e-01,2.17076580e-03,1.63191512e-02
,-4.04435471e-01,1.12803633e-03,-6.66257435e-02,2.28818920e-01]
,[3.20838941e-04,1.40949134e-03,2.67772364e+00,5.24726702e-04
,1.07738676e-03,7.30974716e-01,3.16031295e-04,3.03224842e-04
,-6.14336663e-01,-3.42741604e-04,-8.46691555e-04,-7.74609915e-01]])

Q = np.diag([20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20])  # state cost matrix
R = np.diag([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10])

def solve_DARE(A, B, Q, R, maxiter=200, eps=0.01):
    """
    Solve a discrete time_Algebraic Riccati equation (DARE)
    """
    P = Q

    for i in range(maxiter):
        Pn = A.T @ P @ A - A.T @ P @ B @ \
            inv(R + B.T @ P @ B) @ B.T @ P @ A + Q
        if (abs(Pn - P)).max() < eps:
            break
        P = Pn

    return Pn


def dlqr(A, B, Q, R):
    """
    Solve the discrete time lqr controller.
    x[k+1] = A x[k] + B u[k]
    cost = sum x[k].T*Q*x[k] + u[k].T*R*u[k]
    # ref Bertsekas, p.151
    """

    # first, try to solve the ricatti equation
    P = solve_DARE(A, B, Q, R)

    # compute the LQR gain
    K = inv(B.T @ P @ B + R) @ (B.T @ P @ A)

    eigVals, eigVecs = eig(A - B @ K)
    return K, P, eigVals


def lqr_control(x):
    #K, _, _ = dlqr(A, B, Q, R)
    
    u = Kd @ x
    return u


def run(pos0, target, u_prev):
    # Initial position
    x0 = np.array(pos0)

    # Target
    xref_ = np.array(target)
    xref = np.concatenate((xref_, xref_, xref_, xref_)) 

    """
    # U target
    uref_ = np.array([0.0, 0.0, 0.0])
    uref = np.concatenate((uref_, uref_, uref_, uref_))

    # U init         
    uminus1_ = np.array(u_prev) 
    uminus1 = np.concatenate((uminus1_, uminus1_, uminus1_, uminus1_)) 

    # Bounds
    xmin_ = np.array([-4500, -3000, -1e9]) 
    xmin = np.concatenate((xmin_, xmin_, xmin_, xmin_)) 

    xmax_ = np.array([4500, 3000, 1e9]) 
    xmax = np.concatenate((xmax_, xmax_, xmax_, xmax_)) 

    umin_ = np.array([-2, -2, -2]) 
    umin = np.concatenate((umin_, umin_, umin_, umin_)) 

    umax_ = np.array([2, 2, 2]) 
    umax = np.concatenate((umax_, umax_, umax_, umax_)) 

    Dumin_ = np.array([-1, -1, -0.5]) 
    Dumin = np.concatenate((Dumin_, Dumin_, Dumin_, Dumin_)) 

    Dumax_ = np.array([1, 1, 0.5]) 
    Dumax = np.concatenate((Dumax_, Dumax_, Dumax_, Dumax_)) 
    """

    u = lqr_control(xref - x0)

    return u


K, _, _ = dlqr(A, B, Q, R)
print(K)
 

    
